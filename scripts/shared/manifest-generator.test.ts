import { describe, it, expect } from 'vitest';
import { generateManifest, validateManifest, parseManifest } from './manifest-generator';
import type { UserscriptManifest } from './manifest';

describe('Manifest Generator', () => {
  describe('generateManifest', () => {
    it('should generate basic manifest', () => {
      const manifest: UserscriptManifest = {
        name: 'Test Script',
        version: '1.0.0',
      };

      const result = generateManifest(manifest, { padValues: false, sectionSeparators: false });

      expect(result).toContain('// ==UserScript==');
      expect(result).toContain('// @name Test Script');
      expect(result).toContain('// @version 1.0.0');
      expect(result).toContain('// ==/UserScript==');
    });

    it('should handle array directives', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        match: ['https://example.com/*', 'https://test.com/*'],
        grant: ['GM_setValue', 'GM_getValue'],
      };

      const result = generateManifest(manifest, { padValues: false, sectionSeparators: false });

      expect(result).toContain('// @match https://example.com/*');
      expect(result).toContain('// @match https://test.com/*');
      expect(result).toContain('// @grant GM_setValue');
      expect(result).toContain('// @grant GM_getValue');
    });

    it('should handle resources', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        resource: [
          { name: 'icon', url: 'https://example.com/icon.png' },
          { name: 'style', url: 'https://example.com/style.css' },
        ],
      };

      const result = generateManifest(manifest, { padValues: false, sectionSeparators: false });

      expect(result).toContain('// @resource icon https://example.com/icon.png');
      expect(result).toContain('// @resource style https://example.com/style.css');
    });

    it('should pad values when enabled', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        description: 'A test script',
      };

      const result = generateManifest(manifest, { padValues: true, sectionSeparators: false });
      const lines = result.split('\n');

      // Find lines with directives
      const nameLine = lines.find((l) => l.includes('@name'));
      const versionLine = lines.find((l) => l.includes('@version'));
      const descLine = lines.find((l) => l.includes('@description'));

      // Check that padding exists
      expect(nameLine).toMatch(/\/\/\s@name\s+Test/);
      expect(versionLine).toMatch(/\/\/\s@version\s+1\.0\.0/);
      expect(descLine).toMatch(/\/\/\s@description\s+A test script/);
    });

    it('should add section separators', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        match: ['*://*/*'],
        grant: ['GM_setValue'],
      };

      const result = generateManifest(manifest, { sectionSeparators: true, padValues: false });

      // Should have empty lines between sections
      expect(result).toMatch(/\/\/\s*\n\/\/\s@match/);
    });

    it('should handle boolean directives', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        noframes: true,
      };

      const result = generateManifest(manifest, { padValues: false, sectionSeparators: false });

      expect(result).toContain('// @noframes');
    });

    it('should throw error without name', () => {
      const manifest = {
        version: '1.0.0',
      } as UserscriptManifest;

      expect(() => generateManifest(manifest)).toThrow('Manifest requires "name" field');
    });

    it('should throw error without version', () => {
      const manifest = {
        name: 'Test',
      } as UserscriptManifest;

      expect(() => generateManifest(manifest)).toThrow('Manifest requires "version" field');
    });

    it('should add custom header comment', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
      };

      const result = generateManifest(manifest, {
        headerComment: 'Generated by ViteMonkey',
        padValues: false,
        sectionSeparators: false,
      });

      expect(result).toContain('// Generated by ViteMonkey');
      expect(result.indexOf('// Generated by ViteMonkey')).toBeLessThan(
        result.indexOf('// ==UserScript==')
      );
    });

    it('should follow directive order', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        author: 'Author',
        description: 'Description',
        match: ['*://*/*'],
        grant: ['GM_setValue'],
      };

      const result = generateManifest(manifest, { padValues: false, sectionSeparators: false });
      const lines = result.split('\n').filter((l) => l.includes('@'));

      // Name should come before version
      const nameIndex = lines.findIndex((l) => l.includes('@name'));
      const versionIndex = lines.findIndex((l) => l.includes('@version'));
      const matchIndex = lines.findIndex((l) => l.includes('@match'));
      const grantIndex = lines.findIndex((l) => l.includes('@grant'));

      expect(nameIndex).toBeLessThan(versionIndex);
      expect(versionIndex).toBeLessThan(matchIndex);
      expect(matchIndex).toBeLessThan(grantIndex);
    });
  });

  describe('validateManifest', () => {
    it('should pass valid manifest', () => {
      const manifest: UserscriptManifest = {
        name: 'Test Script',
        version: '1.0.0',
        match: ['https://example.com/*'],
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toHaveLength(0);
    });

    it('should warn about missing name', () => {
      const manifest = {
        version: '1.0.0',
      } as UserscriptManifest;

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('Missing required field: name');
    });

    it('should warn about missing version', () => {
      const manifest = {
        name: 'Test',
      } as UserscriptManifest;

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('Missing required field: version');
    });

    it('should warn about invalid version format', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: 'v1.0',
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('Version should follow semantic versioning (e.g., 1.0.0)');
    });

    it('should warn about missing URL patterns', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('No URL matching patterns defined (match or include)');
    });

    it('should warn about grant "none" with other permissions', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        match: ['*://*/*'],
        grant: ['none' as any, 'GM_setValue'],
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('Grant "none" should not be combined with other permissions');
    });

    it('should warn about conflicting homepage directives', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        match: ['*://*/*'],
        homepage: 'https://example.com',
        homepageURL: 'https://example.com',
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('Both homepage and homepageURL defined (use one)');
    });

    it('should warn about invalid URLs', () => {
      const manifest: UserscriptManifest = {
        name: 'Test',
        version: '1.0.0',
        match: ['*://*/*'],
        homepage: 'not-a-url',
      };

      const warnings = validateManifest(manifest);
      expect(warnings).toContain('homepage should be a valid URL (http:// or https://)');
    });
  });

  describe('parseManifest', () => {
    it('should parse basic manifest', () => {
      const source = `
// ==UserScript==
// @name         Test Script
// @version      1.0.0
// @description  A test script
// ==/UserScript==

console.log('test');
`;

      const manifest = parseManifest(source);

      expect(manifest.name).toBe('Test Script');
      expect(manifest.version).toBe('1.0.0');
      expect(manifest.description).toBe('A test script');
    });

    it('should parse array directives', () => {
      const source = `
// ==UserScript==
// @name         Test
// @version      1.0.0
// @match        https://example.com/*
// @match        https://test.com/*
// @grant        GM_setValue
// @grant        GM_getValue
// ==/UserScript==
`;

      const manifest = parseManifest(source);

      expect(manifest.match).toEqual(['https://example.com/*', 'https://test.com/*']);
      expect(manifest.grant).toEqual(['GM_setValue', 'GM_getValue']);
    });

    it('should parse resources', () => {
      const source = `
// ==UserScript==
// @name         Test
// @version      1.0.0
// @resource     icon https://example.com/icon.png
// @resource     style https://example.com/style.css
// ==/UserScript==
`;

      const manifest = parseManifest(source);

      expect(manifest.resource).toEqual([
        { name: 'icon', url: 'https://example.com/icon.png' },
        { name: 'style', url: 'https://example.com/style.css' },
      ]);
    });

    it('should return empty manifest for invalid source', () => {
      const source = 'console.log("no manifest here");';

      const manifest = parseManifest(source);

      expect(manifest).toEqual({});
    });

    it('should handle padded directives', () => {
      const source = `
// ==UserScript==
// @name           Test Script
// @version        1.0.0
// @description    A test script
// ==/UserScript==
`;

      const manifest = parseManifest(source);

      expect(manifest.name).toBe('Test Script');
      expect(manifest.version).toBe('1.0.0');
      expect(manifest.description).toBe('A test script');
    });
  });

  describe('Round-trip conversion', () => {
    it('should preserve manifest through generate/parse cycle', () => {
      const original: UserscriptManifest = {
        name: 'Test Script',
        version: '1.0.0',
        description: 'A test script',
        author: 'Test Author',
        match: ['https://example.com/*'],
        grant: ['GM_setValue', 'GM_getValue'],
      };

      const generated = generateManifest(original);
      const parsed = parseManifest(generated);

      expect(parsed.name).toBe(original.name);
      expect(parsed.version).toBe(original.version);
      expect(parsed.description).toBe(original.description);
      expect(parsed.author).toBe(original.author);
      expect(parsed.match).toEqual(original.match);
      expect(parsed.grant).toEqual(original.grant);
    });
  });
});
